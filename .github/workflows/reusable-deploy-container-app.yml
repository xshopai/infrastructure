# ==============================================================================
# Reusable Workflow: Deploy Container App to Azure Container Apps
# ==============================================================================
# This reusable workflow deploys any microservice to Azure Container Apps.
# 
# IMPORTANT: Container Apps must be created by infrastructure (Layer 4) first!
# This workflow only updates existing Container Apps with new images.
#
# It handles:
# - Building Docker image
# - Pushing to Azure Container Registry
# - Updating existing Container App with new image
# - Waiting for deployment to complete
# - Health checks
#
# Prerequisites:
# - Run infrastructure workflow Layer 4 to create the Container App first
# - Container App must already exist in the target resource group
#
# Usage in calling workflow:
#   jobs:
#     deploy:
#       uses: xshopai/infrastructure/.github/workflows/reusable-deploy-container-app.yml@main
#       with:
#         service_name: customer-ui
#         environment: dev
#       secrets: inherit
# ==============================================================================

name: Reusable - Deploy Container App

on:
  workflow_call:
    inputs:
      # Required inputs
      service_name:
        description: 'Name of the service (e.g., customer-ui, user-service)'
        required: true
        type: string
      
      environment:
        description: 'Target environment (dev, staging, prod)'
        required: true
        type: string
        default: 'dev'
      
      # Optional inputs with defaults
      dockerfile_path:
        description: 'Path to Dockerfile relative to service root'
        required: false
        type: string
        default: 'Dockerfile'
      
      docker_context:
        description: 'Docker build context path'
        required: false
        type: string
        default: '.'
      
      docker_target:
        description: 'Docker build target stage (e.g., production, development)'
        required: false
        type: string
        default: 'production'
      
      container_port:
        description: 'Port the container listens on'
        required: false
        type: number
        default: 8080
      
      # Dapr configuration
      dapr_enabled:
        description: 'Enable Dapr sidecar'
        required: false
        type: boolean
        default: false
      
      dapr_app_protocol:
        description: 'Dapr app protocol (http or grpc)'
        required: false
        type: string
        default: 'http'
      
      dapr_app_port:
        description: 'Port Dapr sidecar communicates with app'
        required: false
        type: number
        default: 8080
      
      # Resource configuration
      cpu:
        description: 'CPU cores (e.g., 0.25, 0.5, 1)'
        required: false
        type: string
        default: '0.25'
      
      memory:
        description: 'Memory (e.g., 0.5Gi, 1Gi)'
        required: false
        type: string
        default: '0.5Gi'
      
      min_replicas:
        description: 'Minimum number of replicas'
        required: false
        type: number
        default: 0
      
      max_replicas:
        description: 'Maximum number of replicas'
        required: false
        type: number
        default: 3
      
      # Ingress configuration
      ingress_enabled:
        description: 'Enable external ingress'
        required: false
        type: boolean
        default: true
      
      ingress_external:
        description: 'External (internet) or internal only'
        required: false
        type: boolean
        default: true
      
      # Health probes
      health_probe_path:
        description: 'Health check endpoint path'
        required: false
        type: string
        default: '/health'
      
      # Environment variables (JSON string)
      env_vars:
        description: 'Environment variables as JSON array'
        required: false
        type: string
        default: '[]'
      
      # Secrets from Key Vault (JSON string)
      secrets:
        description: 'Secrets to mount from Key Vault as JSON array'
        required: false
        type: string
        default: '[]'
      
      # Image tag override
      image_tag:
        description: 'Override image tag (default: git SHA)'
        required: false
        type: string
        default: ''
      
      # Azure resource names (optional - will be looked up if not provided)
      acr_name:
        description: 'Azure Container Registry name (without .azurecr.io)'
        required: false
        type: string
        default: ''
      
      resource_group:
        description: 'Resource group name (default: rg-xshopai-{environment})'
        required: false
        type: string
        default: ''

    outputs:
      fqdn:
        description: 'Fully qualified domain name of the deployed app'
        value: ${{ jobs.deploy.outputs.fqdn }}
      revision_name:
        description: 'Name of the deployed revision'
        value: ${{ jobs.deploy.outputs.revision_name }}
      image:
        description: 'Full image name with tag'
        value: ${{ jobs.deploy.outputs.image }}

permissions:
  id-token: write
  contents: read
  packages: write

jobs:
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      image_full: ${{ steps.meta.outputs.tags }}
      acr_name: ${{ steps.resources.outputs.acr_name }}
      resource_group: ${{ steps.resources.outputs.resource_group }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Discover Azure Resources
        id: resources
        run: |
          # Use provided values or discover from Azure
          RESOURCE_GROUP="${{ inputs.resource_group }}"
          if [ -z "$RESOURCE_GROUP" ]; then
            RESOURCE_GROUP="rg-xshopai-${{ inputs.environment }}"
          fi
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          
          ACR_NAME="${{ inputs.acr_name }}"
          if [ -z "$ACR_NAME" ]; then
            # Look up ACR in resource group
            ACR_NAME=$(az acr list --resource-group "$RESOURCE_GROUP" --query "[0].name" -o tsv 2>/dev/null || echo "")
            if [ -z "$ACR_NAME" ]; then
              echo "âŒ No ACR found in resource group $RESOURCE_GROUP"
              exit 1
            fi
          fi
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ Resource Group: $RESOURCE_GROUP"
          echo "ðŸ³ ACR: $ACR_NAME"

      - name: Login to ACR
        run: |
          az acr login --name ${{ steps.resources.outputs.acr_name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.resources.outputs.acr_name }}.azurecr.io/${{ inputs.service_name }}
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=${{ inputs.image_tag }},enable=${{ inputs.image_tag != '' }}
            type=raw,value=latest,enable=${{ inputs.environment == 'prod' }}
            type=raw,value=${{ inputs.environment }}-latest

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.docker_context }}
          file: ${{ inputs.docker_context }}/${{ inputs.dockerfile_path }}
          target: ${{ inputs.docker_target }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ steps.meta.outputs.version }}

      - name: Output image info
        run: |
          echo "### ðŸ³ Docker Image Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Service** | ${{ inputs.service_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | ${{ steps.meta.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Registry** | ${{ steps.resources.outputs.acr_name }}.azurecr.io |" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to Container Apps
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ inputs.environment }}
    
    outputs:
      fqdn: ${{ steps.deploy.outputs.fqdn }}
      revision_name: ${{ steps.deploy.outputs.revision_name }}
      image: ${{ needs.build.outputs.image_full }}
    
    env:
      RESOURCE_GROUP: ${{ needs.build.outputs.resource_group }}
      ACR_NAME: ${{ needs.build.outputs.acr_name }}
      CONTAINER_ENV: xshopai-${{ inputs.environment }}-cae
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Container Apps Environment ID
        id: cae
        run: |
          CAE_ID=$(az containerapp env show \
            --name ${{ env.CONTAINER_ENV }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query id -o tsv)
          echo "id=$CAE_ID" >> $GITHUB_OUTPUT

      - name: Get ACR credentials
        id: acr
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query "passwords[0].value" -o tsv)
          echo "::add-mask::$ACR_PASSWORD"
          echo "username=$ACR_USERNAME" >> $GITHUB_OUTPUT
          echo "password=$ACR_PASSWORD" >> $GITHUB_OUTPUT

      - name: Prepare environment variables
        id: env
        run: |
          # Start with user-provided env vars
          ENV_VARS='${{ inputs.env_vars }}'
          
          # Add standard env vars
          STANDARD_VARS='[
            {"name": "ENVIRONMENT", "value": "${{ inputs.environment }}"},
            {"name": "SERVICE_NAME", "value": "${{ inputs.service_name }}"},
            {"name": "APPLICATIONINSIGHTS_CONNECTION_STRING", "secretRef": "appinsights-connection-string"}
          ]'
          
          # Merge env vars (user vars take precedence)
          if [ "$ENV_VARS" != "[]" ]; then
            MERGED=$(echo "$STANDARD_VARS $ENV_VARS" | jq -s 'add | unique_by(.name)')
          else
            MERGED="$STANDARD_VARS"
          fi
          
          echo "vars=$MERGED" >> $GITHUB_OUTPUT

      - name: Deploy Container App
        id: deploy
        run: |
          IMAGE="${{ env.ACR_NAME }}.azurecr.io/${{ inputs.service_name }}:${{ needs.build.outputs.image_tag }}"
          APP_NAME="${{ inputs.service_name }}"
          
          # Check if app exists - Container App must be created by infrastructure
          APP_EXISTS=$(az containerapp show \
            --name "$APP_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query name -o tsv 2>/dev/null || echo "")
          
          if [ -z "$APP_EXISTS" ]; then
            echo "âŒ Container App '$APP_NAME' does not exist in resource group '${{ env.RESOURCE_GROUP }}'!"
            echo ""
            echo "ðŸ“‹ Container Apps should be created by infrastructure deployment (Layer 4)."
            echo "   Run the infrastructure workflow first:"
            echo "   1. Go to: https://github.com/xshopai/infrastructure/actions/workflows/azure-container-apps-layered-deploy.yml"
            echo "   2. Run with layer: layer4-container-apps"
            echo "   3. Then re-run this workflow"
            echo ""
            exit 1
          fi
          
          echo "âœ… Found existing Container App: $APP_NAME"
          echo "ðŸ“¦ Updating with image: $IMAGE"
          
          # Update existing app with new image
          az containerapp update \
            --name "$APP_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image "$IMAGE"
          
          # Get deployment info
          FQDN=$(az containerapp show \
            --name "$APP_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" -o tsv)
          
          REVISION=$(az containerapp show \
            --name "$APP_NAME" \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "properties.latestRevisionName" -o tsv)
          
          echo "fqdn=$FQDN" >> $GITHUB_OUTPUT
          echo "revision_name=$REVISION" >> $GITHUB_OUTPUT
          
          echo "âœ… Deployed $APP_NAME"
          echo "   FQDN: $FQDN"
          echo "   Revision: $REVISION"

      - name: Wait for deployment
        run: |
          APP_NAME="${{ inputs.service_name }}"
          echo "Waiting for deployment to complete..."
          
          for i in {1..30}; do
            STATUS=$(az containerapp revision show \
              --name "${{ steps.deploy.outputs.revision_name }}" \
              --app "$APP_NAME" \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "properties.runningState" -o tsv 2>/dev/null || echo "Unknown")
            
            echo "Attempt $i: Status = $STATUS"
            
            if [ "$STATUS" == "Running" ]; then
              echo "âœ… Deployment is running!"
              break
            elif [ "$STATUS" == "Failed" ]; then
              echo "âŒ Deployment failed!"
              exit 1
            fi
            
            sleep 10
          done

      - name: Health check
        if: inputs.ingress_enabled && inputs.ingress_external
        run: |
          FQDN="${{ steps.deploy.outputs.fqdn }}"
          HEALTH_PATH="${{ inputs.health_probe_path }}"
          
          if [ -n "$FQDN" ] && [ "$HEALTH_PATH" != "" ]; then
            echo "Running health check on https://$FQDN$HEALTH_PATH"
            
            for i in {1..10}; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://$FQDN$HEALTH_PATH" || echo "000")
              
              if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "204" ]; then
                echo "âœ… Health check passed! (HTTP $HTTP_CODE)"
                break
              else
                echo "Attempt $i: HTTP $HTTP_CODE - waiting..."
                sleep 15
              fi
            done
          else
            echo "Skipping health check (no FQDN or health path)"
          fi

      - name: Deployment Summary
        run: |
          echo "### ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Service** | ${{ inputs.service_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ inputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image** | ${{ env.ACR_NAME }}.azurecr.io/${{ inputs.service_name }}:${{ needs.build.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Revision** | ${{ steps.deploy.outputs.revision_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **URL** | https://${{ steps.deploy.outputs.fqdn }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note:** Container App configuration (CPU, memory, replicas, Dapr) is managed by infrastructure (Layer 4)." >> $GITHUB_STEP_SUMMARY

      - name: Azure Logout
        if: always()
        run: az logout
